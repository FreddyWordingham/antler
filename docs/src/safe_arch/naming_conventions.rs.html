<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/safe_arch-0.6.0/src/naming_conventions.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>naming_conventions.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../safe_arch/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../safe_arch/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../safe_arch/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
</pre><pre class="rust"><code><span class="doccomment">//! An explanation of the crate&#39;s naming conventions.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! This crate attempts to follow the general naming scheme of `verb_type` when</span>
<span class="doccomment">//! the operation is &quot;simple&quot;, and `verb_description_words_type` when the</span>
<span class="doccomment">//! operation (op) needs to be more specific than normal. Like this:</span>
<span class="doccomment">//! * `add_m128`</span>
<span class="doccomment">//! * `add_saturating_i8_m128i`</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Types</span>
<span class="doccomment">//! Currently, only `x86` and `x86_64` types are supported. Among those types:</span>
<span class="doccomment">//! * `m128` and `m256` are always considered to hold `f32` lanes.</span>
<span class="doccomment">//! * `m128d` and `m256d` are always considered to hold `f64` lanes.</span>
<span class="doccomment">//! * `m128i` and `m256i` hold integer data, but each op specifies what lane</span>
<span class="doccomment">//!   width of integers the operation uses.</span>
<span class="doccomment">//! * If the type has `_s` on the end then it&#39;s a &quot;scalar&quot; operation that</span>
<span class="doccomment">//!   affects just the lowest lane. The other lanes are generally copied forward</span>
<span class="doccomment">//!   from one of the inputs, though the details there vary from op to op.</span>
<span class="doccomment">//! * The SIMD types are often referred to as &quot;registers&quot; because each SIMD</span>
<span class="doccomment">//!   typed value represents exactly one CPU register when you&#39;re doing work.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Operations</span>
<span class="doccomment">//! There&#39;s many operations that can be performed. When possible, `safe_arch`</span>
<span class="doccomment">//! tries to follow normal Rust naming (eg: adding is still `add` and left</span>
<span class="doccomment">//! shifting is still `shl`), but if an operation doesn&#39;t normally exist at all</span>
<span class="doccomment">//! in Rust then we basically have to make something up.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Many operations have more than one variant, such as `add` and also</span>
<span class="doccomment">//! `add_saturating`. In this case, `safe_arch` puts the &quot;core operation&quot; first</span>
<span class="doccomment">//! and then any &quot;modifiers&quot; go after, which isn&#39;t how you might normally say it</span>
<span class="doccomment">//! in English, but it makes the list of functions sort better.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! As a general note on SIMD terminology: When an operation uses the same</span>
<span class="doccomment">//! indexed lane in two _different_ registers to determine the output, that is a</span>
<span class="doccomment">//! &quot;vertical&quot; operation. When an operation uses more than one lane in the</span>
<span class="doccomment">//! _same_ register to determine the output, that is a &quot;horizontal&quot; operation.</span>
<span class="doccomment">//! * Vertical: `out[0] = a[0] + b[0]`, `out[1] = a[1] + b[1]`</span>
<span class="doccomment">//! * Horizontal: `out[0] = a[0] + a[1]`, `out[1] = b[0] + b[1]`</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Operation Glossary</span>
<span class="doccomment">//! Here follows the list of all the main operations and their explanations.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * `abs`: Absolute value (wrapping).</span>
<span class="doccomment">//! * `add`: Addition. This is &quot;wrapping&quot; by default, though some other types of</span>
<span class="doccomment">//!   addition are available. Remember that wrapping signed addition is the same</span>
<span class="doccomment">//!   as wrapping unsigned addition.</span>
<span class="doccomment">//! * `average`: Averages the two inputs.</span>
<span class="doccomment">//! * `bitand`: Bitwise And, `a &amp; b`, like [the trait](core::ops::BitAnd).</span>
<span class="doccomment">//! * `bitandnot`: Bitwise `(!a) &amp; b`. This seems a little funny at first but</span>
<span class="doccomment">//!   it&#39;s useful for clearing bits. The output will be based on the `b` side&#39;s</span>
<span class="doccomment">//!   bit pattern, but with all active bits in `a` cleared:</span>
<span class="doccomment">//!   * `bitandnot(0b0010, 0b1011) == 0b1001`</span>
<span class="doccomment">//! * `bitor`: Bitwise Or, `a | b`, like [the trait](core::ops::BitOr).</span>
<span class="doccomment">//! * `bitxor`: Bitwise eXclusive Or, `a ^ b`, like [the</span>
<span class="doccomment">//!   trait](core::ops::BitXor).</span>
<span class="doccomment">//! * `blend`: Merge the data lanes of two SIMD values by taking either the `b`</span>
<span class="doccomment">//!   value or `a` value for each lane. Depending on the instruction, the blend</span>
<span class="doccomment">//!   mask can be either an immediate or a runtime value.</span>
<span class="doccomment">//! * `cast`: Convert between data types while preserving the exact bit</span>
<span class="doccomment">//!   patterns, like how [`transmute`](core::mem::transmute) works.</span>
<span class="doccomment">//! * `ceil`: &quot;Ceiling&quot;, rounds towards positive infinity.</span>
<span class="doccomment">//! * `cmp`: Numeric comparisons of various kinds. This generally gives &quot;mask&quot;</span>
<span class="doccomment">//!   output where the output value is of the same data type as the inputs, but</span>
<span class="doccomment">//!   with all the bits in a &quot;true&quot; lane as 1 and all the bits in a &quot;false&quot; lane</span>
<span class="doccomment">//!   as 0. Remember that with floating point values all 1s bits is a NaN, and</span>
<span class="doccomment">//!   with signed integers all 1s bits is -1.</span>
<span class="doccomment">//!   * An &quot;Ordered comparison&quot; checks if _neither_ floating point value is NaN.</span>
<span class="doccomment">//!   * An &quot;Unordered comparison&quot; checks if _either_ floating point value is</span>
<span class="doccomment">//!     NaN.</span>
<span class="doccomment">//! * `convert`: This does some sort of numeric type change. The details can</span>
<span class="doccomment">//!   vary wildly. Generally, if the number of lanes goes down then the lowest</span>
<span class="doccomment">//!   lanes will be kept. If the number of lanes goes up then the new high lanes</span>
<span class="doccomment">//!   will be zero.</span>
<span class="doccomment">//! * `div`: Division.</span>
<span class="doccomment">//! * `dot_product`: This works like the matrix math operation. The lanes are</span>
<span class="doccomment">//!   multiplied and then the results are summed up into a single value.</span>
<span class="doccomment">//! * `duplicate`: Copy the even or odd indexed lanes to the other set of lanes.</span>
<span class="doccomment">//!   Eg, `[1, 2, 3, 4]` becomes `[1, 1, 3, 3]` or `[2, 2, 4, 4]`.</span>
<span class="doccomment">//! * `extract`: Get a value from the lane of a SIMD type into a scalar type.</span>
<span class="doccomment">//! * `floor`: Rounds towards negative infinity.</span>
<span class="doccomment">//! * `fused`: All the fused operations are a multiply as well as some sort of</span>
<span class="doccomment">//!   adding or subtracting. The details depend on which fused operation you</span>
<span class="doccomment">//!   select. The benefit of this operation over a non-fused operation are that</span>
<span class="doccomment">//!   it can compute slightly faster than doing the mul and add separately, and</span>
<span class="doccomment">//!   also the output can have higher accuracy in the result.</span>
<span class="doccomment">//! * `insert`: The opposite of `extract`, this puts a new value into a</span>
<span class="doccomment">//!   particular lane of a SIMD type.</span>
<span class="doccomment">//! * `load`: Reads an address and makes a SIMD register value. The details can</span>
<span class="doccomment">//!   vary because there&#39;s more than one type of `load`, but generally this is a</span>
<span class="doccomment">//!   `&amp;T -&gt; U` style operation.</span>
<span class="doccomment">//! * `max`: Picks the larger value from each of the two inputs.</span>
<span class="doccomment">//! * `min`: Picks the smaller value from each of the two inputs.</span>
<span class="doccomment">//! * `mul`: Multiplication. For floating point this is just &quot;normal&quot;</span>
<span class="doccomment">//!   multiplication, but for integer types you tend to have some options. An</span>
<span class="doccomment">//!   integer multiplication of X bits will produce a 2X bit output, so</span>
<span class="doccomment">//!   generally you&#39;ll get to pick if you want to keep the high half of that,</span>
<span class="doccomment">//!   the low half of that (a normal &quot;wrapping&quot; mul), or &quot;widen&quot; the outputs to</span>
<span class="doccomment">//!   be all the bits at the expense of not multiplying half the lanes the</span>
<span class="doccomment">//!   lanes.</span>
<span class="doccomment">//! * `pack`: Take the integers in the `a` and `b` inputs, reduce them to fit</span>
<span class="doccomment">//!   within the half-sized integer type (eg: `i16` to `i8`), and pack them all</span>
<span class="doccomment">//!   together into the output.</span>
<span class="doccomment">//! * `population`: The &quot;population&quot; operations refer to the bits within an</span>
<span class="doccomment">//!   integer. Either counting them or adjusting them in various ways.</span>
<span class="doccomment">//! * `rdrand`: Use the hardware RNG to make a random value of the given length.</span>
<span class="doccomment">//! * `rdseed`: Use the hardware RNG to make a random seed of the given length.</span>
<span class="doccomment">//!   This is less commonly available, but theoretically an improvement over</span>
<span class="doccomment">//!   `rdrand` in that if you have to combine more than one usage of this</span>
<span class="doccomment">//!   operation to make your full seed size then the guess difficulty rises at a</span>
<span class="doccomment">//!   multiplicative rate instead of just an additive rate. For example, two</span>
<span class="doccomment">//!   `u64` outputs concatenated to a single `u128` have a guess difficulty of</span>
<span class="doccomment">//!   2^(64*64) with `rdseed` but only 2^(64+64) with `rdrand`.</span>
<span class="doccomment">//! * `read_timestamp_counter`: Lets you read the CPU&#39;s cycle counter, which</span>
<span class="doccomment">//!   doesn&#39;t strictly mean anything in particular since even the CPU&#39;s clock</span>
<span class="doccomment">//!   rate isn&#39;t even stable over time, but you might find it interesting as an</span>
<span class="doccomment">//!   approximation during benchmarks, or something like that.</span>
<span class="doccomment">//! * `reciprocal`: Turns `x` into `1/x`. Can also be combined with a `sqrt`</span>
<span class="doccomment">//!   operation.</span>
<span class="doccomment">//! * `round`: Convert floating point values to whole numbers, according to one</span>
<span class="doccomment">//!   of several available methods.</span>
<span class="doccomment">//! * `set`: Places a list of scalar values into a SIMD lane. Conceptually</span>
<span class="doccomment">//!   similar to how building an array works in Rust.</span>
<span class="doccomment">//! * `splat`: Not generally an operation of its own, but a modifier to other</span>
<span class="doccomment">//!   operations such as `load` and `set`. This will copy a given value across a</span>
<span class="doccomment">//!   SIMD type as many times as it can be copied. For example, a 32-bit value</span>
<span class="doccomment">//!   splatted into a 128-bit register will be copied four times.</span>
<span class="doccomment">//! * `shl`: Bit shift left. New bits shifted in are always 0. Because the shift</span>
<span class="doccomment">//!   is the same for both signed and unsigned values, this crate simply marks</span>
<span class="doccomment">//!   left shift as always being an unsigned operation.</span>
<span class="doccomment">//!   * You can shift by an immediate value (&quot;imm&quot;), all lanes by the same value</span>
<span class="doccomment">//!     (&quot;all&quot;), or each lane by its own value (&quot;each&quot;).</span>
<span class="doccomment">//! * `shr`: Bit shift right. This comes in two forms: &quot;Arithmetic&quot; shifts shift</span>
<span class="doccomment">//!   in the starting sign bit (which preserves the sign of the value), and</span>
<span class="doccomment">//!   &quot;Logical&quot; shifts shift in 0 regardless of the starting sign bit (so the</span>
<span class="doccomment">//!   result ends up being positive). With normal Rust types, signed integers</span>
<span class="doccomment">//!   use arithmetic shifts and unsigned integers use logical shifts, so these</span>
<span class="doccomment">//!   functions are marked as being for signed or unsigned integers</span>
<span class="doccomment">//!   appropriately.</span>
<span class="doccomment">//!   * As with `shl`, you can shift by an immediate value (&quot;imm&quot;), all lanes by</span>
<span class="doccomment">//!     the same value (&quot;all&quot;), or each lane by its own value (&quot;each&quot;).</span>
<span class="doccomment">//! * `sign_apply`: Multiplies one set of values by the signum (1, 0, or -1) of</span>
<span class="doccomment">//!   another set of values.</span>
<span class="doccomment">//! * `sqrt`: Square Root.</span>
<span class="doccomment">//! * `store`: Writes a SIMD value to a memory location.</span>
<span class="doccomment">//! * `string_search`: A rather specialized instruction that lets you do byte</span>
<span class="doccomment">//!   based searching within a register. This lets you do some very high speed</span>
<span class="doccomment">//!   searching through ASCII strings when the stars align.</span>
<span class="doccomment">//! * `sub`: Subtract.</span>
<span class="doccomment">//! * `shuffle`: This lets you re-order the data lanes. Sometimes x86/x64 calls</span>
<span class="doccomment">//!   this is called &quot;shuffle&quot;, and sometimes it&#39;s called &quot;permute&quot;, and there&#39;s</span>
<span class="doccomment">//!   no particular reasoning behind the different names, so we just call them</span>
<span class="doccomment">//!   all shuffle.</span>
<span class="doccomment">//!   * `shuffle_{args}_{lane-type}_{lane-sources}_{simd-type}`.</span>
<span class="doccomment">//!   * &quot;args&quot; is the input arguments: `a` (one arg) or `ab` (two args), then</span>
<span class="doccomment">//!     either `v` (runtime-varying) or `i` (immediate). All the immediate</span>
<span class="doccomment">//!     shuffles are macros, of course.</span>
<span class="doccomment">//!   * &quot;lane type&quot; is `f32`, `f64`, `i8`, etc. If there&#39;s a `z` after the type</span>
<span class="doccomment">//!     then you&#39;ll also be able to zero an output position instead of making it</span>
<span class="doccomment">//!     come from a particular source lane.</span>
<span class="doccomment">//!   * &quot;lane sources&quot; is generally either &quot;all&quot; which means that all lanes can</span>
<span class="doccomment">//!     go to all other lanes, or &quot;half&quot; which means that each half of the lanes</span>
<span class="doccomment">//!     is isolated from the other half, and you can&#39;t cross data between the</span>
<span class="doccomment">//!     two halves, only within a half (this is how most of the 256-bit x86/x64</span>
<span class="doccomment">//!     shuffles work).</span>
<span class="doccomment">//! * `unpack`: Takes a SIMD value and gets out some of the lanes while widening</span>
<span class="doccomment">//!   them, such as converting `i16` to `i32`.</span>
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="safe_arch" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>